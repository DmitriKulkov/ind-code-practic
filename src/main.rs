mod matrix;
use matrix::*;
mod input;
use input::*;

fn main() {
  println!("{}", usize::min_value());
  println!("Вас приветствует программа");
  println!("Быстрого перемножения матриц методом Штрассена\n");
  ///////////////////////////////////////////////////////////////////////////////
  ////////////////////Ввод размеров матрицы пользователем////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  println!("Введите размеры первой матрицы\t");
  let (row1, col1) = input_size();
  println!("Введите размеры второй матрицы\t");
  let (row2, col2) = input_size();
  let mut m1 = matrix(row1, col1);
  let mut m2 = matrix(row2, col2);

  ///////////////////////////////////////////////////////////////////////////////
  ////////////////Выбор способа заполнения и заполнение матриц///////////////////
  ///////////////////////////////////////////////////////////////////////////////

  match select_way() {
    Fill::Manually => {
      man_fill_matrix(&mut m1);
      println!("\n");
      man_fill_matrix(&mut m2);
      println!("\nМатрица 1\n");
      print_matrix(&mut m1);
      println!("\nМатрица 2\n");
      print_matrix(&mut m2);
    }
    Fill::Auto => {
      auto_fill_matrix(&mut m1);
      auto_fill_matrix(&mut m2);
      println!("\nМатрица 1\n");
      print_matrix(&mut m1);
      println!("\nМатрица 2\n");
      print_matrix(&mut m2);
    }
  }
  ///////////////////////////////////////////////////////////////////////////////
  /////////////////Приведение матриц к требуемому размеру////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let mut l = 2;
  while l < row1 || l < row2 || l < col1 || l < col2 {
    l *= 2;
  }

  let mut m3 = matrix(l, l);
  let mut m4 = matrix(l, l);

  copy_values(&mut m1, &mut m3);
  copy_values(&mut m2, &mut m4);

  clear_matrix(&mut m1);
  clear_matrix(&mut m2);

  println!("Приведенные матрицы");
  println!("\nМатрица 1\n");
  print_matrix(&mut m3);
  println!("\nМатрица 2\n");
  print_matrix(&mut m4);

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////Разбиение матриц на подматрицы и их заполнение//////////////////
  ///////////////////////////////////////////////////////////////////////////////
  let mut sub_matr = sub_matrices(&mut m3, &mut m4, l / 2);

  clear_matrix(&mut m3);
  clear_matrix(&mut m4);
  ///////////////////////////////////////////////////////////////////////////////
  ////////////////////////Создание промежуточных матриц//////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let mut interm = declare_intermediate_matrices(l / 2);

  ///////////////////////////////////////////////////////////////////////////////
  ////////////////////Вычисление значений промежуточных матриц///////////////////
  ///////////////////////////////////////////////////////////////////////////////

  calc_interm(&mut sub_matr, &mut interm, l / 2);

  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////////Создание вспомогательных матриц/////////////////////////
  ///////////////////////////////////////////////////////////////////////////////
  let mut helpers = vec![matrix(l / 2, l / 2); 4];

  ///////////////////////////////////////////////////////////////////////////////
  ////////////Подсчет значений вспомогательных матриц из промежуточных///////////
  ///////////////////////////////////////////////////////////////////////////////

  calc_helpers(&mut helpers, &mut interm, l / 2);

  for mut i in &mut interm {
    clear_matrix(&mut i);
  }
  interm.clear();
  ///////////////////////////////////////////////////////////////////////////////
  ///////////////////Создание результирующей матрицы/////////////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let mut m5 = matrix(l, l);

  ///////////////////////////////////////////////////////////////////////////////
  ///////Занесение информации из вспомогательных матриц в результирующую/////////
  ///////////////////////////////////////////////////////////////////////////////
  copy_helpers_to_result(&mut helpers, &mut m5, l / 2);

  for mut i in &mut helpers {
    clear_matrix(&mut i);
  }
  interm.clear();
  ///////////////////////////////////////////////////////////////////////////////
  ////////////////Выравнивание границ результирующей матрицы/////////////////////
  ///////////////////////////////////////////////////////////////////////////////

  let (row, col) = matrix_bounds(&mut m5, l);
  let mut m6 = matrix(row, col);

  copy_values(&mut m5, &mut m6);

  clear_matrix(&mut m5);
  println!("Результирующая матрица");

  print_matrix(&mut m6);

  clear_matrix(&mut m6);
}
